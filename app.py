# -*- coding: utf-8 -*-
"""BOSS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/167yQgi1Feoclo8Db8-EYF1xKSpBxzWPl
"""

import plotly.express as px
from dash import Dash, dcc, html, Input, Output
import pandas as pd

# URL para exportar o arquivo como Excel
download_url = "https://docs.google.com/spreadsheets/d/1Ay2rVHcch3YBDk3ADGQ4kTLcSQxVqVQdzC3D0ccVlWI/export?format=xlsx"


# Carregar os dados diretamente do Google Drive
data = pd.read_excel(download_url, sheet_name='CGS')

# Prepare the data
data.rename(columns=lambda x: x.strip(), inplace=True)
data.columns = data.columns.str.replace(' +', '_', regex=True)

# Initialize the Dash app
app = Dash(__name__)

# App layout with Tabs
app.layout = html.Div([
    html.H1("Desempenho dos Jogadores"),

    dcc.Tabs([
        # Tab 1: Análise Geral
        dcc.Tab(label='Análise Geral', children=[
            html.Div([
                html.H2("Desempenho Geral dos Jogadores"),
                dcc.Dropdown(
                    id='metric-filter',
                    options=[
                        {'label': 'Poder de Combate', 'value': 'Poder_de_Combate'},
                        {'label': 'Abates', 'value': 'Abates'},
                        {'label': 'Doações', 'value': 'Doação'}
                    ],
                    value='Poder_de_Combate',
                    placeholder="Escolha uma métrica"
                ),
                dcc.Graph(id='performance-graph'),
                html.Div(id='average-table', style={'font-size': '18px', 'margin-top': '10px'}),
                dcc.Graph(id='stacked-bar-graph'),
                html.Div(id='table-output', style={'margin-top': '20px'})
            ])
        ]),

        # Tab 2: Análise Individual
        dcc.Tab(label='Análise Individual', children=[
            html.Div([
                html.H2("Desempenho Individual dos Jogadores"),
                html.Label("Selecione um ou mais Jogadores:"),
                dcc.Dropdown(
                    id='jogador-filter',
                    options=[{'label': jogador, 'value': jogador} for jogador in data['Jogador'].unique()],
                    value=[],
                    multi=True,
                    placeholder="Todos"
                ),
                dcc.Graph(id='combate-total'),
                dcc.Graph(id='abates-total'),
                dcc.Graph(id='doacoes-total')
            ])
        ])
    ])
])

# Callbacks para a aba "Análise Geral"
@app.callback(
    [Output('performance-graph', 'figure'),
     Output('average-table', 'children'),
     Output('stacked-bar-graph', 'figure'),
     Output('table-output', 'children')],
    Input('metric-filter', 'value')
)
def update_general_analysis(selected_metric):
    # Filtro de jogadores ativos
    active_19 = data[data['Frequencia_(19/01/25)'] == 'ATIVO']
    active_26 = data[data['Frequencia_(26/01/25)'] == 'ATIVO']

    # Totais e médias
    total_19 = active_19[f'{selected_metric}_(19/01/2025)'].sum()
    total_26 = active_26[f'{selected_metric}_(26/01/2025)'].sum()
    mean_19 = total_19 / len(active_19) if len(active_19) > 0 else 0
    mean_26 = total_26 / len(active_26) if len(active_26) > 0 else 0

    # Gráfico de barras horizontais
    performance_data = pd.DataFrame({
        'Data': ['19/01/2025', '26/01/2025'],
        'Total': [total_19, total_26]
    })

    performance_fig = px.bar(
        performance_data,
        y='Data',
        x='Total',
        title=f"Desempenho Geral - {selected_metric.replace('_', ' ')}",
        labels={'Total': 'Total Geral', 'Data': 'Data'},
        orientation='h',
        color='Data',  # Define cores com base na coluna 'Data'
        color_discrete_map={
            '19/01/2025': 'blue',  # Cor azul para 19/01/2025
            '26/01/2025': 'red'    # Cor vermelha para 26/01/2025
             }
    )

    # Tabela de médias
    average_table = html.Table([
        html.Thead(html.Tr([
            html.Th("Média do 19/01/2025"),
            html.Th("Média do 26/01/2025")
        ])),
        html.Tbody(html.Tr([
            html.Td(f"{mean_19:.2f}"),
            html.Td(f"{mean_26:.2f}")
        ]))
    ], style={'width': '50%', 'margin': '0 auto', 'text-align': 'center', 'border': '1px solid black'})

    # Gráfico de barras empilhadas
    above_mean_19 = active_19[active_19[f'{selected_metric}_(19/01/2025)'] >= mean_19]
    below_mean_19 = active_19[active_19[f'{selected_metric}_(19/01/2025)'] < mean_19]
    above_mean_26 = active_26[active_26[f'{selected_metric}_(26/01/2025)'] >= mean_26]
    below_mean_26 = active_26[active_26[f'{selected_metric}_(26/01/2025)'] < mean_26]

    stacked_data = pd.DataFrame({
        'Status': ['Acima ou Igual à Média', 'Abaixo da Média'],
        '19/01/2025': [len(above_mean_19), len(below_mean_19)],
        '26/01/2025': [len(above_mean_26), len(below_mean_26)]
    })

    stacked_fig = px.bar(
        stacked_data,
        x=['19/01/2025', '26/01/2025'],
        y='Status',
        title=f"Distribuição de Jogadores em Relação à Média - {selected_metric.replace('_', ' ')}",
        barmode='stack',
        text_auto=True,
        orientation='h'
    )

    # Relação de jogadores
    table_output = html.Div([
        html.Table([
            html.Thead(html.Tr([
                html.Th("Jogadores Acima ou Igual à Média (19/01/2025)"),
                html.Th("Jogadores Abaixo da Média (19/01/2025)")
            ])),
            html.Tbody(html.Tr([
                html.Td(html.Ul([html.Li(jogador) for jogador in above_mean_19['Jogador']])),
                html.Td(html.Ul([html.Li(jogador) for jogador in below_mean_19['Jogador']])),
            ]))
        ])
    ])

    return performance_fig, average_table, stacked_fig, table_output

# Run the app
if __name__ == '__main__':
    app.run_server(host="0.0.0.0", port=8080)